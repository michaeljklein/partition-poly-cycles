-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/partition-poly-cycles#readme</a>
@package partition-poly-cycles
@version 0.1.0.0

module Data.List.Utils

-- | Break up a list into chunks of size <tt>n</tt>, or <tt>&lt; n</tt> if
--   there are <tt>&lt; n</tt> elements (remaining) in the list
--   
--   <pre>
--   λ&gt; chunks 1 [1..10]
--   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[]]
--   
--   λ&gt; chunks 2 [1..10]
--   [[1,2],[3,4],[5,6],[7,8],[9,10],[]]
--   
--   λ&gt; chunks 3 [1..10]
--   [[1,2,3],[4,5,6],[7,8,9],[10]]
--   </pre>
chunks :: Int -> [a] -> [[a]]

-- | Negate all numbers at odd indices
--   
--   For example:
--   
--   <pre>
--   λ&gt; alternate [0..10]
--   [0,-1,2,-3,4,-5,6,-7,8,-9,10]
--   </pre>
alternate :: Num a => [a] -> [a]

-- | <a>alternate</a> if <a>signum</a>s of the first two elements differ
--   
--   For example:
--   
--   It adds alternation to <tt>[0..10]</tt> because <tt>(signum 0 == 0) /=
--   (signum 1 == 1)</tt>:
--   
--   <pre>
--   λ&gt; autoAlternate [0..10]
--   [0,-1,2,-3,4,-5,6,-7,8,-9,10]
--   </pre>
--   
--   And removes alternation from an already alternating list:
--   
--   <pre>
--   λ&gt; autoAlternate $ alternate [0..10]
--   [0,1,2,3,4,5,6,7,8,9,10]
--   </pre>
autoAlternate :: (Num a, Ord a) => [a] -> [a]

-- | First (forward) differences:
--   
--   <pre>
--   λ&gt; diff [1..10]
--   [1,1,1,1,1,1,1,1,1]
--   </pre>
--   
--   <pre>
--   λ&gt; diff [1,3..10]
--   [2,2,2,2]
--   </pre>
diff :: Num a => [a] -> [a]

-- | Automatically alternate the first differences
--   
--   <pre>
--   <a>autoAlternate</a> . <a>diff</a>
--   </pre>
autoDiff :: (Ord a, Num a) => [a] -> [a]

-- | Take exactly the given number of elements or return <a>Nothing</a>
takeExactly :: Int -> [a] -> Maybe [a]

-- | Find a subsequence <tt>ys</tt> of <tt>xs</tt> such that:
--   
--   <pre>
--   and $ zipWith (==) xs (cycle ys)
--   </pre>
findCycle :: Eq a => [a] -> Maybe [a]

-- | Is the second argument equal to:
--   
--   <pre>
--   take n $ cycle xs
--   </pre>
--   
--   for some <tt>n</tt>?
--   
--   <pre>
--   λ&gt; all (n -&gt; isCycle [1,2] (take n $ cycle [1, 2])) [2..2^12]
--   True
--   (0.53 secs, 1,884,383,408 bytes)
--   
--   λ&gt; any (n -&gt; isCycle [1,2] (take n $ 2 : cycle [1, 2])) [2..2^12]
--   False
--   (0.01 secs, 4,943,968 bytes)
--   </pre>
isCycle :: Eq a => [a] -> [a] -> Bool

-- | <a>Just</a> if the predicate returns <a>True</a>
--   
--   For example, use with <a>mapMaybe</a> to filter a list:
--   
--   <pre>
--   λ&gt; mapMaybe (boolMaybe odd) [1..10]
--   [1,3,5,7,9]
--   </pre>
--   
--   Should be equivalent to:
--   
--   <pre>
--   \p -&gt; liftM2 (&gt;&gt;) ((`unless` Nothing) . p) return
--   </pre>
boolMaybe :: (a -> Bool) -> a -> Maybe a

module Data.PolyF

-- | Base <a>Functor</a> of polynomials with variables and division
data PolyF a
[Var] :: PolyF a
[:+] :: a -> a -> PolyF a
[:-] :: a -> a -> PolyF a
[:*] :: a -> a -> PolyF a
[:/] :: a -> a -> PolyF a

-- | Run a single vase <a>Functor</a> layer of a <tt>Poly</tt>
runPolyF :: Fractional a => PolyF a -> a -> a
instance GHC.Base.Functor Data.PolyF.PolyF
instance GHC.Read.Read a => GHC.Read.Read (Data.PolyF.PolyF a)
instance GHC.Show.Show a => GHC.Show.Show (Data.PolyF.PolyF a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.PolyF.PolyF a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.PolyF.PolyF a)
instance Data.Functor.Classes.Eq1 Data.PolyF.PolyF
instance Data.Functor.Classes.Show1 Data.PolyF.PolyF
instance Data.Functor.Classes.Read1 Data.PolyF.PolyF

module Data.Poly

-- | Univariate polynomials
newtype Poly a
Poly :: Free PolyF a -> Poly a
[unPoly] :: Poly a -> Free PolyF a

-- | <a>Poly</a> variable
var :: Poly a

-- | Convert a list to a <a>Poly</a> if possible
toPoly :: (Eq a, Fractional a) => [a] -> Maybe (Poly a)

-- | Convert a list to a list of <a>Poly</a>s
toPolys :: (Eq a, Fractional a) => [a] -> [Poly a]

-- | Convert to <a>Poly</a> if possible using the given number of elements
toPolyN :: (Eq a, Fractional a) => Int -> [a] -> Maybe (Poly a)

-- | Interpolate a list of <a>Fractional</a> values into a <a>Poly</a>
--   
--   Currently buggy:
--   
--   <pre>
--   λ&gt; runPoly (interpolate [1,2,3]) <a>$</a> [0..3]
--   [1.0,1.0,1.0,1.0]
--   (0.01 secs, 485,672 bytes)
--   </pre>
interpolate :: Fractional a => [a] -> Poly a

-- | Simplify combinations of constants and <tt>x + x</tt>
simplify :: Fractional a => Poly a -> Poly a

-- | Apply a transformation on a <a>Free</a> <a>Monad</a> on all levels,
--   repeating until equivalence using <a>fixEq</a>
freeLevels :: (Functor f, Eq1 f, Eq a) => (Free f a -> Free f a) -> Free f a -> Free f a

-- | Apply the function until it reaches a fixed point
fixEq :: Eq a => (a -> a) -> a -> a

-- | Examples:
--   
--   <pre>
--   λ&gt; simplifyAll (1 + 2 + 3 :: Poly Double)
--   Poly {unPoly = Pure 6.0}
--   
--   λ&gt; simplifyAll (1 + 2 + 3 + var :: Poly Double)
--   Poly {unPoly = Free (:+ (Pure 6.0) (Free Var))}
--   
--   λ&gt; simplifyAll (1 + 2 + 3 * (var + var) :: Poly Double)
--   Poly {unPoly = Free (:+ (Pure 3.0) (Free (:* (Pure 3.0) (Free (:* (Pure 2.0) (Free Var))))))}
--   </pre>
simplifyAll :: (Fractional a, Eq a) => Poly a -> Poly a

-- | <a>wrap</a> after applying a binary function
wrap2 :: MonadFree m f => (a -> b -> m (f c)) -> a -> b -> f c

-- | Evaluate a univariate polynomial on the given input
runPoly :: Fractional a => Poly a -> a -> a
instance GHC.Base.Monad Data.Poly.Poly
instance GHC.Base.Applicative Data.Poly.Poly
instance GHC.Base.Functor Data.Poly.Poly
instance GHC.Read.Read a => GHC.Read.Read (Data.Poly.Poly a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Poly.Poly a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Poly.Poly a)
instance Control.Monad.Free.Class.MonadFree Data.PolyF.PolyF Data.Poly.Poly
instance GHC.Num.Num a => GHC.Num.Num (Data.Poly.Poly a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Data.Poly.Poly a)

module Lib

-- | <tt><a>parts</a> k n</tt> is the number of partitions of <tt>n</tt>
--   elements mutually disjoint subsets of at most <tt>k</tt> elements
parts :: (Num a, Ord a, Num p) => a -> a -> p

-- | <a>parts</a> decreasing inputs
prop_partsDecInputs :: Integer -> Integer -> Property

-- | <a>parts</a> with specific handling for more cases
parts1 :: (Num a, Ord a, Num p) => a -> a -> p

-- | <a>parts1</a> to <a>parts2</a>
prop_parts1ToParts2 :: Integer -> Integer -> Bool

-- | <a>parts</a> for equal positive inputs equal to <tt>1</tt>
--   
--   <pre>
--   (x -&gt; (1 <a>x) ==</a> (parts x x == 1))
--   </pre>
prop_partsOnLine1 :: Integer -> Property

-- | <a>parts</a> version 2
parts2 :: (Num a, Ord a, Num p) => a -> a -> p

-- | <a>parts1</a> to <a>parts2</a> with a modulus
prop_parts1ToParts2Mod :: Integer -> Integer -> Bool

-- | <a>parts</a> version 3
parts3 :: (Integral a, Ord a) => a -> a -> a

-- | <a>parts2</a> to <a>parts3</a>
prop_parts2ToParts3 :: Integer -> Integer -> Bool

-- | <a>parts</a> version 4
--   
--   <pre>
--   p 3 n = p 3 (n - 3) + p 2 (n - 1)
--     p 3 (n - 3) = p 3 (n - 6) + p 2 (n - 4) = p 3 (n - 6) + (2 * (n - 4) - 1 + (- 1) ^ (4 * n)) <a>div</a> 4 = p 3 (n - 6) + (2 * n - 8) <a>div</a> 4 = p 3 (n - 6) + (n - 4) <a>div</a> 2
--     p 2 (n - 1) = p 2 (n - 3) + p 1 (n - 2) = p 2 (n - 3) + 1 = (2 * (n - 3) - 1 + (- 1) ^ (n - 3)) <a>div</a> 4 = (2 * n - 6 - (- 1) ^ n) <a>div</a> 4
--   p 3 n = p 3 (n - 6) + (n - 4) <a>div</a> 2 + (2 * n - 6 - (- 1) ^ n) <a>div</a> 4
--   p 3 n = p 3 (n - 6) + (2 * n - 8 + 2 * n - 6 - (- 1) ^ n) <a>div</a> 4
--   p 3 n = p 3 (n - 6) + (4 * n - 14 - (- 1) ^ n) <a>div</a> 4
--   </pre>
parts4 :: (Integral a, Ord a) => a -> a -> a

-- | Relation for multiples of arguments
--   
--   <pre>
--   (x y -&gt; (x &gt; y &amp;&amp; 0 <a>==</a> (parts4 x (x + y) == parts4 y (2 * y)))
--   </pre>
prop_parts4PlusTimes :: Integer -> Integer -> Property

-- | <a>parts</a> version 5
parts5 :: (Integral a, Ord a) => a -> a -> a

-- | <a>parts</a> version 5
--   
--   Alternate implementation of <tt>part5</tt>
parts6 :: Integer -> Integer -> Integer

-- | <tt>part4</tt> to <tt>part5</tt>
prop_parts4ToParts5 :: Integer -> Integer -> Bool

-- | Example cyclic series
--   
--   <pre>
--   scanl(+) c (cycle [a1, a2, .., an])
--   </pre>
cyclicSeriesEx :: Num a => [a]

-- | <tt>part5</tt> to <a>cyclicSeriesEx</a>
prop_part5ToCyclicSeriesEx :: Bool

-- | <a>ff</a> to <a>cyclicSeriesEx</a>
prop_ffToCyclicSeriesEx :: Bool

-- | See <a>prop_ffToCyclicSeriesEx</a>
ff :: Integral a => a -> a

-- | Find a "poly cycle", i.e. a cycle that results from taking
--   <a>alternate</a>'s and <a>diff</a>'s of the original series.
--   
--   Such a cycle can always be reconstituted into a piecewise polynomial,
--   with cases for each residue modulo the period of the cycle.
findPolyCycle :: Integral a => a -> Maybe ([a], Int)

-- | <a>findPolyCycle</a> with a given period, applied to <a>parts5</a>
findPolyCycleN :: Integral a => a -> Int -> Maybe ([a], Int)

-- | <a>findCycle</a> and print, from <a>autoAlternate</a>ing <a>parts5</a>
exampleFindCycle :: (Show a, Integral a) => a -> Int -> IO ()

-- | Nest a function <tt>n</tt> times on the input
nest :: Int -> (a -> a) -> a -> a

-- | <a>Integral</a> log base <tt>2</tt>
log2 :: Integral a => a -> a

-- | <a>mapM_</a> with timing information printed
mapMTimed_ :: (a -> IO ()) -> [a] -> IO ()

-- | Run and get duration using <a>getCurrentTime</a>
timed :: IO () -> IO NominalDiffTime

-- | <pre>
--   <a>findPolyCycleN</a> 6 <a>$</a> [1..]
--   </pre>
runMain :: IO ()
runTests :: IO Bool
