-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/basic#readme</a>
@package basic
@version 0.1.0.0

module Lib

-- | <tt><a>parts</a> k n</tt> is the number of partitions of <tt>n</tt>
--   elements mutually disjoint subsets of at most <tt>k</tt> elements
parts :: (Num a, Ord a, Num p) => a -> a -> p

-- | <a>parts</a> decreasing inputs
prop_partsDecInputs :: Integer -> Integer -> Property

-- | <a>parts</a> with specific handling for more cases
parts1 :: (Num a, Ord a, Num p) => a -> a -> p

-- | <a>parts1</a> to <a>parts2</a>
prop_parts1ToParts2 :: Integer -> Integer -> Bool

-- | <a>parts</a> for equal positive inputs equal to <tt>1</tt>
--   
--   <pre>
--   (x -&gt; (1 <a>x) ==</a> (parts x x == 1))
--   </pre>
prop_partsOnLine1 :: Integer -> Property

-- | <a>parts</a> version 2
parts2 :: (Num a, Ord a, Num p) => a -> a -> p

-- | <a>parts1</a> to <a>parts2</a> with a modulus
prop_parts1ToParts2Mod :: Integer -> Integer -> Bool

-- | <a>parts</a> version 3
parts3 :: (Integral a, Ord a) => a -> a -> a

-- | <a>parts2</a> to <a>parts3</a>
prop_parts2ToParts3 :: Integer -> Integer -> Bool

-- | <a>parts</a> version 4
--   
--   <pre>
--   p 3 n = p 3 (n - 3) + p 2 (n - 1)
--     p 3 (n - 3) = p 3 (n - 6) + p 2 (n - 4) = p 3 (n - 6) + (2 * (n - 4) - 1 + (- 1) ^ (4 * n)) <a>div</a> 4 = p 3 (n - 6) + (2 * n - 8) <a>div</a> 4 = p 3 (n - 6) + (n - 4) <a>div</a> 2
--     p 2 (n - 1) = p 2 (n - 3) + p 1 (n - 2) = p 2 (n - 3) + 1 = (2 * (n - 3) - 1 + (- 1) ^ (n - 3)) <a>div</a> 4 = (2 * n - 6 - (- 1) ^ n) <a>div</a> 4
--   p 3 n = p 3 (n - 6) + (n - 4) <a>div</a> 2 + (2 * n - 6 - (- 1) ^ n) <a>div</a> 4
--   p 3 n = p 3 (n - 6) + (2 * n - 8 + 2 * n - 6 - (- 1) ^ n) <a>div</a> 4
--   p 3 n = p 3 (n - 6) + (4 * n - 14 - (- 1) ^ n) <a>div</a> 4
--   </pre>
parts4 :: (Integral a, Ord a) => a -> a -> a

-- | Relation for multiples of arguments
--   
--   <pre>
--   (x y -&gt; (x &gt; y &amp;&amp; 0 <a>==</a> (parts4 x (x + y) == parts4 y (2 * y)))
--   </pre>
prop_parts4PlusTimes :: Integer -> Integer -> Property

-- | <a>parts</a> version 5
parts5 :: (Integral a, Ord a) => a -> a -> a

-- | <a>parts</a> version 5
--   
--   Alternate implementation of <tt>part5</tt>
parts6 :: Integer -> Integer -> Integer

-- | <tt>part4</tt> to <tt>part5</tt>
prop_parts4ToParts5 :: Integer -> Integer -> Bool

-- | Example cyclic series
--   
--   <pre>
--   scanl(+) c (cycle [a1, a2, .., an])
--   </pre>
cyclicSeriesEx :: Num a => [a]

-- | <tt>part5</tt> to <a>cyclicSeriesEx</a>
prop_part5ToCyclicSeriesEx :: Bool

-- | <a>ff</a> to <a>cyclicSeriesEx</a>
prop_ffToCyclicSeriesEx :: Bool

-- | Break up a list into chunks of size <tt>n</tt>, or <tt>&lt; n</tt> if
--   there are <tt>&lt; n</tt> elements (remaining) in the list
chunks :: Int -> [a] -> [[a]]

-- | Negate all numbers at odd indices
alternate :: Num a => [a] -> [a]

-- | <a>alternate</a> if <a>signum</a>s of the first two elements differ
autoAlternate :: (Num a, Ord a) => [a] -> [a]

-- | See <a>prop_ffToCyclicSeriesEx</a>
ff :: Integral a => a -> a

-- | Convert a list to a <a>Poly</a> if possible
toPoly :: (Eq a, Fractional a) => [a] -> Maybe (Poly a)

-- | Convert a list of a list of <a>Poly</a>s
toPolys :: (Eq a, Fractional a) => [a] -> [Poly a]

-- | Convert to <a>Poly</a> if possible using the given number of elements
toPolyN :: (Eq a, Fractional a) => Int -> [a] -> Maybe (Poly a)

-- | Take exactly the given number of elements or return <a>Nothing</a>
takeExactly :: Int -> [a] -> Maybe [a]

-- | Interpolate a list of <a>Fractional</a> values into a <a>Poly</a>
interpolate :: Fractional a => [a] -> Poly a

-- | Polynomials with variables and division
data PolyF a
[Var] :: PolyF a
[:+] :: a -> a -> PolyF a
[:-] :: a -> a -> PolyF a
[:*] :: a -> a -> PolyF a
[:/] :: a -> a -> PolyF a

-- | <a>Poly</a> variable
var :: Poly a

-- | Univariate polynomials
newtype Poly a
Poly :: Free PolyF a -> Poly a
[unPoly] :: Poly a -> Free PolyF a

-- | Simplify combinations of constants and <tt>x / x</tt>
simplify :: Fractional a => Poly a -> Poly a

-- | <a>wrap</a> after applying a binary function
wrap2 :: MonadFree m f => (a -> b -> m (f c)) -> a -> b -> f c

-- | Evaluate a univariate polynomial on the given input
runPoly :: Fractional a => Poly a -> a -> a

-- | Run a single <a>Functor</a> layer of a <a>Poly</a>
runPolyF :: Fractional a => PolyF a -> a -> a

-- | Map over the head of a <a>NonEmpty</a> list
mapHead1 :: (a -> a) -> NonEmpty a -> NonEmpty a

-- | First differences
diff :: Num a => [a] -> [a]

-- | Find a subsequence <tt>ys</tt> of <tt>xs</tt> such that:
--   
--   <pre>
--   and $ zipWith (==) xs (cycle ys)
--   </pre>
findCycle :: Eq a => [a] -> Maybe [a]

-- | Find a "poly cycle", i.e. a cycle that results from taking
--   <a>alternate</a>'s and <a>diff</a>'s of the original series.
--   
--   Such a cycle can always be reconstituted into a piecewise polynomial,
--   with cases for each residue modulo the period of the cycle.
findPolyCycle :: Integral a => a -> Maybe ([a], Int)

-- | <a>findPolyCycle</a> with a given period
findPolyCycleN :: Integral a => a -> Int -> Maybe ([a], Int)

-- | <a>findCycle</a> and print, from <a>autoAlternate</a>ing <a>parts5</a>
exampleFindCycle :: (Show a, Integral a) => a -> Int -> IO ()

-- | Automatically alternate the first differences
--   
--   <pre>
--   <a>autoAlternate</a> . <a>diff</a>
--   </pre>
autoDiff :: (Ord a, Num a) => [a] -> [a]

-- | Nest a function <tt>n</tt> times on the input
nest :: Int -> (a -> a) -> a -> a

-- | Is the second argument equal to:
--   
--   <pre>
--   take n $ cycle xs
--   </pre>
--   
--   for some <tt>n</tt>?
isCycle :: Eq a => [a] -> [a] -> Bool

-- | <a>Just</a> if the predicate returns <a>True</a>
boolMaybe :: (a -> Bool) -> a -> Maybe a

-- | <a>Integral</a> log base <tt>2</tt>
log2 :: Integral a => a -> a

-- | <a>mapM_</a> with timing information printed
mapMTimed_ :: (a -> IO ()) -> [a] -> IO ()

-- | Run and get duration using <a>getCurrentTime</a>
timed :: IO () -> IO NominalDiffTime

-- | <pre>
--   <a>findPolyCycleN</a> 6 <a>$</a> [1..]
--   </pre>
runMain :: IO ()
runTests :: IO Bool
instance GHC.Base.Monad Lib.Poly
instance GHC.Base.Applicative Lib.Poly
instance GHC.Base.Functor Lib.Poly
instance GHC.Read.Read a => GHC.Read.Read (Lib.Poly a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.Poly a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Poly a)
instance GHC.Base.Functor Lib.PolyF
instance GHC.Read.Read a => GHC.Read.Read (Lib.PolyF a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.PolyF a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.PolyF a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.PolyF a)
instance Control.Monad.Free.Class.MonadFree Lib.PolyF Lib.Poly
instance GHC.Num.Num a => GHC.Num.Num (Lib.Poly a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Lib.Poly a)
instance Data.Functor.Classes.Eq1 Lib.PolyF
instance Data.Functor.Classes.Show1 Lib.PolyF
instance Data.Functor.Classes.Read1 Lib.PolyF
